#include <iostream>
#include <vector>
using namespace std;
//템플릿 코딩(Template Coding)
//>> C++ 에서는 STL이라는 표준 템플릿을 제공
//   특정 자료구조에 대한 것들을 제공해줌으로써
//   편하게 데이터를 사요할 수 있음
//
//장점 : 1. 직접 구현하기 번거로울 수 있는 특정 데이터를 구현하지 않고
//          제공받아 쓰기 때문에 개발 시간이 단축됨
//       2. 코드의 통일성이 보장되서, 정형화된 개발이 가능 
//		 3. 런타임 속도가 빠른편
//
// 단점  : 1. 컴파일이 느림
//         2. 파일 규모가 크게 구현됨
//		   3. 	

//벡터(vector)
//배열처럼 연속된 메모리 영역을 사용
//
// 차이점
// 배열은 한번 만들면 데이터의 추가가 안되지만
// 벡터는 데이터의 추가와 삭제가 가능
//
// 벡터의 특징 또는 벡터를 쓰기 적합한 상황
//1.  저장하고자 하는 데이터의 갯수가 가변적인 경우
//2. 중간에 위치한 데이터를 삭제하거나 삽입하지 않는 상황
// >> 불가능한건 아니나 비효율적
//3. 검색 기능이 많이 필요하지 않는 경우
//4. 특정 위치에 있는 데이터를 빠르게 접근하는 경우
// >> 배열처럼 인덱스 개념으로 접근하기 때문에 좋음


int main()
{
	// 1. 백터 생성
	//vector<자료형> 백터명;

	vector<int> v;// int 형태의 데이터를 저장할 수 있는 vector
	vector<string> v2; //string 형태의 데이터를 저장할 수 있는 vector

	// 2. 벡터 생성 + 크기 설정
	// vector<자료형> 백터명(크기);
	vector<int> v3(5); // int형 벡터, 저장 크기 = 5개, 기본 값 0

	// 3. 벡터 생성 + 값 초기화
	// vector<자료형> 백터명={값1, 값2, ...}
	vector<string> v4 = { "t","a","e" }; //string형태 벡터, 저장 크기 = 3개, 값 : "t","a","e"

	// 4. 벡터 배열
	// vector<자료형> 벡터명[] = {{ 값1, 값2,.. } , { 값1, 값2 ..}};
	vector<int> v5[] = { {0,2} ,{7,1,4} };
	vector<vector<int>> v6; // vector <int> 형 벡터

	// 벡터 사용
	vector<string>zb1;

	// 벡터에 데이터 추가
	zb1.push_back("김태래");
	// vector가 string 으로 지정되어 있기 때문에 string 이외의 데이터는 들어갈 수 없음
	//이런 부분이 STL을 사용하는 이유중 하나 (타입 안정성)
	zb1.push_back("장하오");
	zb1.push_back("박건욱");

	//값 접근
	cout << zb1[0] << endl; //배열과 동일

	//전체 출력(for 문)
	// 벡터명.size()는 현제 벡터의 크기(데이터의 개수)를 return 함
	for (int i = 0; i < zb1.size(); i++)
	{
		cout << zb1[i] << endl;
	}
	cout << endl;

	//값 제거
	zb1.pop_back();

	//전체 출력(iterator)
	//iterator는 STL 자료구조의 데이터를 순차적으로 접근할 수 있는 데이터
	// 해당 문법을 활용할 경우, STL에서는 동일한 문법으로 데이터를 뽑을 수 있음

	//배열 for 문(묶음 형태일 때만 사용 가능)
	//for(자료형 변수명: 묶음형 데이터)
	//{
	//    여기서 변수명은 해당 데이터의 각각의 값을 의미
	//    반복할 때마다 자동으로 다음 값으로 넘어감
	//
	//}
	for (auto iter : zb1)
	{
		cout << iter << endl;
	}

	// 일반적인 for문으로 iterator 쓰기
	//벡터.begin(): 벡터의 시작값(iterator 기준)
	//벡터.end(): 벡터의 마지막 값(iterator 기준)
	for (auto iter = zb1.begin(); iter < zb1.end(); iter++)
	{
		cout << *iter << endl;
		//위치 기반으로 찾기 때문에 가리키는 문법인 포인터(*) 사용
	}

	return 0;

}